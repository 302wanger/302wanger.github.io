<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>七种经典排序算法</title>
      <link href="/2020/03/12/%E4%B8%83%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/12/%E4%B8%83%E7%A7%8D%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>转载自:<br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></p><p>经典排序算法总结与实现<br>发表于 2014-02-09<br>  |   分类于 <a href="http://wuchong.me/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">程序设计 </a>  |   <a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#comments" target="_blank" rel="noopener"></a>  |   阅读次数 2258</p><p>经典排序算法在面试中占有很大的比重，也是基础，为了未雨绸缪，在寒假里整理并用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。希望能帮助到有需要的同学。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。<br>本篇博客所有排序实现均默认从小到大。<br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#一、冒泡排序-BubbleSort" target="_blank" rel="noopener"></a>一、冒泡排序 BubbleSort<br><strong>介绍：</strong><br>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br><strong>步骤：</strong><br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><p><strong>源代码：</strong>(python实现)</p><pre><code>def bubble_sort(arry): n = len(arry) #获得数组的长度 for i in range(n): for j in range(1,n-i): if arry[j-1]         &gt; arry[j] : #如果前者比后者大 arry[j-1],arry[j] = arry[j],arry[j-1] #则交换两者 return arry</code></pre><p>不过针对上述代码还有两种优化方案。<br>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>这两种优化方案的实现可以详见<a href="https://github.com/wuchong/Algorithm-Interview/blob/master/Sort/python/BubbleSort.py">这里</a>。<br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#二、选择排序-SelectionSort" target="_blank" rel="noopener"></a>二、选择排序 SelectionSort<br><strong>介绍：</strong><br>选择排序无疑是最简单直观的排序。它的工作原理如下。<br><strong>步骤：</strong><br>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>以此类推，直到所有元素均排序完毕。</p><p><strong>源代码：</strong>(python实现)<br>def select_sort(ary): n = len(ary) for i in range(0,n): min = i #最小元素下标标记 for j in range(i+1,n): if ary[j] &lt; ary[min] : min = j #找到最小值的下标 ary[min],ary[i] = ary[i],ary[min] #交换两者 return ary</p><p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#三、插入排序-InsertionSort" target="_blank" rel="noopener"></a>三、插入排序 InsertionSort<br><strong>介绍：</strong><br>插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br><strong>步骤：</strong><br>从第一个元素开始，该元素可以认为已经被排序<br>取出下一个元素，在已经排序的元素序列中从后向前扫描<br>如果被扫描的元素（已排序）大于新元素，将该元素后移一位<br>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>将新元素插入到该位置后<br>重复步骤2~5</p><p><strong>排序演示：</strong><br><a href="http://wuchong.me/img/Insertion-sort-example-300px.gif" target="_blank" rel="noopener">[图片上传中。。。（1）]</a><br><strong>源代码：</strong>(python实现)<br>def insert_sort(ary): n = len(ary) for i in range(1,n): if ary[i] &lt; ary[i-1]: temp = ary[i] index = i #待插入的下标 for j in range(i-1,-1,-1): #从i-1 循环到 0 (包括0) if ary[j] &gt; temp : ary[j+1] = ary[j] index = j #记录待插入下标 else : break ary[index] = temp return ary</p><p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#四、希尔排序-ShellSort" target="_blank" rel="noopener"></a>四、希尔排序 ShellSort<br><strong>介绍：</strong><br>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。<br>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。<br>例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]<br>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：<br>13 14 94 33 8225 59 94 65 2345 27 73 25 3910</p><p>然后我们对每列进行排序：<br>10 14 73 25 2313 27 94 33 3925 59 94 65 8245</p><p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]<br>。这时10已经移至正确位置了，然后再以3为步长进行排序：<br>10 14 7325 23 1327 94 3339 25 5994 65 8245</p><p>排序之后变为：<br>10 14 1325 23 3327 25 5939 65 7345 94 8294</p><p>最后以1步长进行排序（此时就是简单的插入排序了）。<br><strong>源代码：</strong>(python实现)<br>def shell_sort(ary): n = len(ary) gap = round(n/2) #初始步长 , 用round四舍五入取整 while gap &gt; 0 : for i in range(gap,n): #每一列进行插入排序 , 从gap 到 n-1 temp = ary[i] j = i while ( j &gt;= gap and ary[j-gap] &gt; temp ): #插入排序 ary[j] = ary[j-gap] j = j - gap ary[j] = temp gap = round(gap/2) #重新设置步长 return ary</p><p>上面源码的步长的选择是从n/2<br>开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在<a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="noopener">维基百科</a>上有对于步长串行的详细介绍。<br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#五、归并排序-MergeSort" target="_blank" rel="noopener"></a>五、归并排序 MergeSort<br><strong>介绍：</strong><br>归并排序是采用分治法的一个非常典型的应用。归并<br>排序的思想就是先递归<br>分解数组，再合<br>并数组。<br>先考虑合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。<br>再考虑递归分解，基本思路是将数组分解成left<br>和right<br>，如果这两个数组内部数据是有序的，那么就可以用上面合并数组的方法将这两个数组合并排序。如何让这两个数组内部是有序的？可以再二分，直至分解出的小组只含有一个元素时为止，此时认为该小组内部已有序。然后合并排序相邻二个小组即可。<br><strong>排序演示：</strong><br><a href="http://wuchong.me/img/Merge-sort-example-300px.gif" target="_blank" rel="noopener">[图片上传中。。。（2）]</a><br><strong>源代码：</strong>(python实现)<br>def merge_sort(ary): if len(ary) &lt;= 1 : return ary num = int(len(ary)/2) #二分分解 left = merge_sort(ary[:num]) right = merge_sort(ary[num:]) return merge(left,right) #合并数组def merge(left,right): ‘’’合并操作， 将两个有序数组left[]和right[]合并成一个大的有序数组’’’ l,r = 0,0 #left与right数组的下标指针 result = [] while l&lt;len(left) and r&lt;len(right) : if left[l] &lt; right[r]: result.append(left[l]) l += 1 else: result.append(right[r]) r += 1 result += left[l:] result += right[r:] return result</p><p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#六、快速排序-QuickSort" target="_blank" rel="noopener"></a>六、快速排序 QuickSort<br><strong>介绍：</strong>快速排序通常明显比同为<em>Ο(n log n)</em>的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。<br><strong>步骤：</strong><br>从数列中挑出一个元素作为基准数。<br>分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。<br>再对左右区间递归执行第二步，直至各区间只有一个数。</p><p><strong>排序演示：</strong><br><a href="http://wuchong.me/img/Quicksort-example.gif" target="_blank" rel="noopener">[图片上传中。。。（3）]</a><br><strong>源代码：</strong>(python实现)<br>def quick_sort(ary): return qsort(ary,0,len(ary)-1)def qsort(ary,left,right): #快排函数，ary为待排序数组，left为待排序的左边界，right为右边界 if left &gt;= right : return ary key = ary[left] #取最左边的为基准数 lp = left #左指针 rp = right #右指针 while lp &lt; rp : while ary[rp] &gt;= key and lp &lt; rp : rp -= 1 while ary[lp] &lt;= key and lp &lt; rp : lp += 1 ary[lp],ary[rp] = ary[rp],ary[lp] ary[left],ary[lp] = ary[lp],ary[left] qsort(ary,left,lp-1) qsort(ary,rp+1,right) return ary</p><p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#七、堆排序-HeapSort" target="_blank" rel="noopener"></a>七、堆排序 HeapSort<br><strong>介绍：</strong><br>堆排序在 top K 问题中使用比较频繁。堆排序是采用二叉堆的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似完全二叉树 。<br><strong>二叉堆具有以下性质：</strong><br>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>每个节点的左右子树都是一个二叉堆（都是最大堆或最小堆）。</p><p><strong>步骤：</strong><br>构造最大堆（Build_Max_Heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2<br>开始的元素均为大根堆。于是只要从n/2-1<br>开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。</p><p>堆排序（HeapSort）：由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。思想是移除根节点，并做最大堆调整的递归运算。第一次将heap[0]<br>与heap[n-1]<br>交换，再对heap[0…n-2]<br>做最大堆调整。第二次将heap[0]<br>与heap[n-2]<br>交换，再对heap[0…n-3]<br>做最大堆调整。重复该操作直至heap[0]<br>和heap[1]<br>交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</p><p>最大堆调整（Max_Heapify）：该方法是提供给上述两个过程调用的。目的是将堆的末端子节点作调整，使得子节点永远小于父节点 。</p><p><strong>排序演示：</strong><br><a href="http://wuchong.me/img/Heapsort-example.gif" target="_blank" rel="noopener">[图片上传中。。。（4）]</a><br><strong>源代码：</strong>(python实现)<br>def heap_sort(ary) : n = len(ary) first = int(n/2-1) #最后一个非叶子节点 for start in range(first,-1,-1) : #构造大根堆 max_heapify(ary,start,n-1) for end in range(n-1,0,-1): #堆排，将大根堆转换成有序数组 ary[end],ary[0] = ary[0],ary[end] max_heapify(ary,0,end-1) return ary#最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点#start为当前需要调整最大堆的位置，end为调整边界def max_heapify(ary,start,end): root = start while True : child = root*2 +1 #调整节点的子节点 if child &gt; end : break if child+1 &lt;= end and ary[child] &lt; ary[child+1] : child = child+1 #取较大的子节点 if ary[root] &lt; ary[child] : #较大的子节点成为父节点 ary[root],ary[child] = ary[child],ary[root] #交换 root = child else : break</p><p><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#总结" target="_blank" rel="noopener"></a>总结<br>下面为七种经典排序算法指标对比情况：<br><a href="http://ww1.sinaimg.cn/large/81b78497jw1emncvtdf1qj20u10afn0r.jpg" target="_blank" rel="noopener">[图片上传中。。。（5）]</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#参考资料" target="_blank" rel="noopener"></a>参考资料<br>维基百科：<a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">希尔排序</a>，<a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">快速排序</a>，<a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">归并排序</a>，<a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">堆排序</a><br><a href="http://blog.csdn.net/morewindows/article/details/7961256" target="_blank" rel="noopener">白话经典算法系列</a><br><a href="http://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html" target="_blank" rel="noopener">排序算法可视化</a><br><a href="http://blog.csdn.net/super_chris/article/details/4581900" target="_blank" rel="noopener">所谓堆和堆排序</a><br><a href="http://6924918.blog.51cto.com/6914918/1260860" target="_blank" rel="noopener">几种经典排序算法</a></p><p>注：本文所有源代码已共享到<a href="https://github.com/wuchong/Algorithm-Interview/tree/master/Sort/python">GitHub</a>。<br>-EOF-</p><p><a href="http://wuchong.me/copyright" target="_blank" rel="noopener">**著作权归作者所有</a></p><p><a href="http://wuchong.me/tags/%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">#算法</a> <a href="http://wuchong.me/tags/Python/" target="_blank" rel="noopener">#Python</a> <a href="http://wuchong.me/tags/%E9%9D%A2%E8%AF%95/" target="_blank" rel="noopener">#面试</a><br>分享到：新浪微博微信TwitterFacebook<a href="http://www.jiathis.com/share" target="_blank" rel="noopener">更多</a>4</p><p><a href="http://wuchong.me/blog/2014/01/27/python-spider-gif/" target="_blank" rel="noopener">** Python爬虫：暴走漫画上的GIF趣图</a><br> <a href="http://wuchong.me/blog/2014/02/25/jquery-datatable-sort-plugin/" target="_blank" rel="noopener">jQuery.dataTables 自定义排序 **</a></p><p>文章目录<br> 站点概览</p><p>**<br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#一、冒泡排序-BubbleSort" target="_blank" rel="noopener">1. 一、冒泡排序 BubbleSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#二、选择排序-SelectionSort" target="_blank" rel="noopener">2. 二、选择排序 SelectionSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#三、插入排序-InsertionSort" target="_blank" rel="noopener">3. 三、插入排序 InsertionSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#四、希尔排序-ShellSort" target="_blank" rel="noopener">4. 四、希尔排序 ShellSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#五、归并排序-MergeSort" target="_blank" rel="noopener">5. 五、归并排序 MergeSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#六、快速排序-QuickSort" target="_blank" rel="noopener">6. 六、快速排序 QuickSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#七、堆排序-HeapSort" target="_blank" rel="noopener">7. 七、堆排序 HeapSort</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#总结" target="_blank" rel="noopener">8. 总结</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/#参考资料" target="_blank" rel="noopener">9. 参考资料</a></p><p>**</p><p>© 2013 - 2016 ** WuChong<br>由 <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a> 强力驱动<br> 主题 - <a href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的JavaScript(上卷)-第四章-提升</title>
      <link href="/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8F%90%E5%8D%87/"/>
      <url>/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<ol><li>先有鸡还是先有蛋？什么意思</li><li>编译器再度来袭？什么意思</li><li>函数优先？</li><li>小结？</li></ol><h3 id="第一个问题：先有鸡还是先有蛋？"><a href="#第一个问题：先有鸡还是先有蛋？" class="headerlink" title="第一个问题：先有鸡还是先有蛋？"></a>第一个问题：先有鸡还是先有蛋？</h3><p>来看代码：</p><pre><code>a = 2;var a;console.log(a);// 会输出什么？ 2console.log(a);var a = 2;// 会输出什么？ undefined</code></pre><p>为什么会这么输出呢？？？？</p><h3 id="编译器再度来袭。回答第一个问题"><a href="#编译器再度来袭。回答第一个问题" class="headerlink" title="编译器再度来袭。回答第一个问题"></a>编译器再度来袭。回答第一个问题</h3><p>先有蛋（声明），再有鸡（赋值）；<br>这个过程就好像变量和函数从他们代码中出现的位置被移动到了最上边，这个过程就叫提升。<br>注意：<br>    只有声明本书被提升，而赋值或其他运行逻辑会被留在原地。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol><li>我们习惯将var a = 2;看作一个声明，而实际上JavaScript引擎并不这么认为，它将var a 和a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。</li><li>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象的想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。</li><li>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。</li><li>要避免重复声明，特别是当普通的var声明和函数声明混在一起的时候，否则会引起很多危险的问题！</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的JavaScript(上卷)-第四章-混合对象类</title>
      <link href="/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/"/>
      <url>/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B7%B7%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="这一章到底在说什么？"><a href="#这一章到底在说什么？" class="headerlink" title="这一章到底在说什么？"></a>这一章到底在说什么？</h2><p>面向类的设计模式：实例化、继承、多态。</p><h2 id="具体怎么说的？"><a href="#具体怎么说的？" class="headerlink" title="具体怎么说的？"></a>具体怎么说的？</h2><h3 id="4-1：类理论"><a href="#4-1：类理论" class="headerlink" title="4.1：类理论"></a>4.1：类理论</h3><p>什么是类：类/继承表述了一种代码的组织结构形式——一种在软件中对真实世界中问题领域的建模方法。<br>类同时也是一种设计模式，但是在js中是否使用它你可以自己决定。</p><h3 id="4-2-类的机制"><a href="#4-2-类的机制" class="headerlink" title="4.2: 类的机制"></a>4.2: 类的机制</h3><p>类和实例的概念来自于房屋建造，类似设计图和房子的关系。<br><em>构造函数</em>：属于类，而且通常和类同名。此外使用new来调用，这样语言引擎才知道你要构造一个新的类实例。</p><h3 id="4-3-类的继承"><a href="#4-3-类的继承" class="headerlink" title="4.3: 类的继承"></a>4.3: 类的继承</h3><p>子类可以复制父类的方法，同时可以重写父类的方法。<br>Js中并不提供多重继承的功能，而是通过其他方法。</p><h3 id="4-4-混入"><a href="#4-4-混入" class="headerlink" title="4.4: 混入"></a>4.4: 混入</h3><p>在继承或者实例化湿，js的对象机制并不会自动执行复制行为。简单来说，js中只有对象，并不存在被实例化的类。一个对象并不会被复制到其他对象，它们会被关联起来。<br>由于其他语言类表现出来的都是复制行为，因此js开发者使用混入来模拟类的复制行为。混入也分：显示和隐式混入。</p><h2 id="和我有什么关系？"><a href="#和我有什么关系？" class="headerlink" title="和我有什么关系？"></a>和我有什么关系？</h2><p>对于js的类进行了一次解析，有助于理解底层的某些思路。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。js也有类似的语法，但是和其他语言中的类完全不同。</li><li>类意味着复制。</li><li>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。</li><li>多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。</li><li>JavaScript并不会（像类那样）自动创建对象的副本。</li><li>混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显示伪多态(otherObj.methodName.call(this,…)),这会让代码更加难懂并且难以维护。此外，显示混入实际上无法完全模拟类的复制行为，因为对象（和函数）只能复制引用，无法复制被引用的对象或函数本身。忽视这一点会导致许多问题。</li><li>总的来说，在js中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的JavaScript(上卷)-第三章-对象</title>
      <link href="/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%8A%E5%8D%B7-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一：这一章到底在说什么？"><a href="#一：这一章到底在说什么？" class="headerlink" title="一：这一章到底在说什么？"></a>一：这一章到底在说什么？</h2><p>详细介绍对象。</p><ol><li>语法</li><li>类型</li><li>内容<ol><li>可计算属性</li><li>属性和方法</li><li>数组</li><li>复制对象</li><li>属性描述符</li><li>不变性</li><li>[Get]</li><li>[Put]</li><li>Getter和Setter</li><li>存在性</li></ol></li><li>遍历</li></ol><h2 id="二：作者具体说了什么，怎么说的？"><a href="#二：作者具体说了什么，怎么说的？" class="headerlink" title="二：作者具体说了什么，怎么说的？"></a>二：作者具体说了什么，怎么说的？</h2><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1:语法"></a>3.1:语法</h3><p>创建对象的两种方式：声明形式和构造形式。</p><p><em>声明形式</em>：</p><pre><code>Var myObject = {    key: value,    // ….}</code></pre><p><em>构造形式</em>：</p><pre><code>Var myObj = new Object();myObj.key = value</code></pre><p><em>两种形式的区别</em>：</p><ol><li>声明形式可以添加多个键/值对（一般也都是这种方式创建对象）</li><li>构造形式必须逐个添加属性</li></ol><h3 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2: 类型"></a>3.2: 类型</h3><p>对象是JavaScript的基础，其中有一些对象子类型，被称为内置对象。如下：</p><ol><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error<br>这些内置对象很像其他语言中的type或class，但是实际上只是一些内置函数。这些内置函数可以当作构造函数来使用，从而构造出一个对应子类型的新对象。比如：<pre><code>Var strObject = new String(“i am a stirng”)Typeof strObject; // object</code></pre></li></ol><h2 id="3-3-内容"><a href="#3-3-内容" class="headerlink" title="3.3: 内容"></a>3.3: 内容</h2><p><em>3.3.1:可计算属性名</em><br>可以在文字形式中使用[]包括一个表达式当作属性名<br>代码如下：</p><pre><code>var preFix = “foo”;var myObject = {  [preFix + “bar”]: “hello”,  [preFix + “baz”]: “world”};myObject[“foobar”]; // hellomyObject[“foobaz”]; // world</code></pre><p>可计算属性命最常用的场景可能是es6的符号(Symbol) ,这是一种新的基础数据类型，包含一个不透明且无法预测的值。比如：</p><pre><code>var mySymbol = {  [Symbol.SomeName]: “hello world”};          </code></pre><p><em>3.3.2 属性与方法</em></p><p><em>3.3.3: 数组</em><br>数组其实也是对象的一种，你可以给数组添加属性，但是不推荐这么用。<br>比如：</p><pre><code>var myArr = [“foo”, 3, “bar”]myArr.baz = “baz”;myArr.length; // 3myArr.baz; // baz</code></pre><p><em>3.3.4: 复制对象</em><br>会有深复制、浅复制的区别，同时JSON.toString方法。<br><em>3.3.5:属性表述符</em><br>对象属性对应的属性描述符。比如</p><pre><code>var myObject = {    a: 2}Object.defineProperty(myObject, “a”, {    value: 2,    writable: true, //是否可以修改属性的值    configurable: true, // 是否可配置    enumerable: true //是否出现在for…in等枚举中})</code></pre><p><em>3.3.6:不变性</em><br>举个例子：我不想让myArr.first的值发生变化，有哪几种方式？</p><pre><code>myArr.first; // [1,2,3]myArr.first.push(4); myArr.first; // [1,2,3,4]</code></pre><ol><li>对象常量：结合 writeable:false和configurable:false设置</li><li>禁止拓展：Object.preventExtensions(myArr.first)</li><li>密封：Object.seal(myArr.first); 该方法会创建一个密封的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions并把所有现有属性编辑位configurable:false</li><li>冻结：Object.freeze(…):该方法会创建一个冻结对象，这歌方法会在现有对象上调用Object.seal(…)并把所有数据访问属性标记为writeable:false</li></ol><p><em>3.3.7 [Get]</em><br>看如下代码：</p><pre><code>var myObject = {    a: undefined}myObject.a; // undefinedmyObject.b; // undefined</code></pre><p>myObject.a 实际上执行了[get]操作（有点像函数调用:[get]）。对象内置的[get] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个值。<br>而像myObject.b没有找到的话，会执行另一个种非常重要的行为。（即原型链）。尽管myObject.a和myObject.b 都返回了undefined ,但是实际上底层的[get]对object.b进行了更复杂的处理。</p><p><em>3.3.8: 【Put】</em><br>   【Put】被触发时，实际的行为取决于许多对象，包括对象中是否已经存在这个属性。<br>如果已经存在这个属性，会检查以下内容：</p><ol><li>属性是否是访问描述符？如果是并且存在setter就调用setter</li><li>属性的数据描述符中writable 是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出TypeError异常。</li><li>如果都不是，将该值设置为属性的值。</li></ol><p><em>3.3.9 Getter和Setter</em></p><p>分别可以控制属性值的设置和获取。</p><p><em>3.3.10</em>存在性<br>我们可以在不访问属性值的情况下判断对象中是否存在这个属性。</p><pre><code>var myObecjt = {    a: 2}myObject.hasOwnProperty(“a”); // truemyObject.hasOwnProperty(“b”); // false</code></pre><h3 id="3-4-遍历"><a href="#3-4-遍历" class="headerlink" title="3.4: 遍历"></a>3.4: 遍历</h3><p><em>有几种遍历的方式呢？</em></p><ol><li>fo…in ：用了遍历对象的可枚举属性列表(包含Prototype链)</li><li>forEach(…):会遍历数组中的所有值并忽略回调函数的返回值。</li><li>every(…)：一直运行直到回调函数返回false</li><li>some(…)：一直运行直到回调函数返回true</li><li>for…of: 首先会访问被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。</li></ol><pre><code>var myArray = [1, 2, 3];var it = myArray[Symbol.iterator]();it.next(); // {value:1, done: false}it.next(); // {value:2, done: false}it.next(); // {value:3, done: false}it.next(); // {done: true}</code></pre><h2 id="三：这一章跟你有什么关系？"><a href="#三：这一章跟你有什么关系？" class="headerlink" title="三：这一章跟你有什么关系？"></a>三：这一章跟你有什么关系？</h2><p>对象的全面解析，是js语言的重点啊，熟悉底层原理是很重要的。</p><h2 id="四：本章小结："><a href="#四：本章小结：" class="headerlink" title="四：本章小结："></a>四：本章小结：</h2><ol><li>Js中的对象有字面形式(var a = {…})和构造形式(var a = new Array(…))。字面形式更常用，不过有时构造形式可以提供更多选项。</li><li>许多人都认为“JavaScript 中万物都是对象”，这是错误的。对象是6个基础类型之一。对象有包括function在内的子类型，不同子类型具有不同的行为，比如内部标签[object Array ]表示这是对象的子类型数组。</li><li>对象就是键/值 对 的集合，可以通过.propName或者 [“propName”]语法来获取属性值。访问属性时，引擎实际上会调用内部的默认[Get]操作，[Get]操作会检查对象本身是否包含这个属性，如果没找到的话还会查找[Prototype]链</li><li>属性的特性可以通过属性描述符来控制，比如writable和configurable.此外，可以使用Object.preventExtensions(…) \ Object.seal(…) \ Object.freeze(…)来设置对象的不可变性级别。</li><li>属性不一定包含值—它们可能是具备getter/setter 的“访问描述符”。此外，属性可以时可枚举或者不可枚举的，这决定了它们是否会出现在for…in循环中。</li><li>你可以使用for…of语法来遍历数据结构（数组、对象，等等）中的值，for…of会寻找内置或自定义的@@iterator对象并调用它的 next()方法来遍历数据值。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的JavaScript(中卷)-第一章-类型</title>
      <link href="/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%AD%E5%8D%B7-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/03/12/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript-%E4%B8%AD%E5%8D%B7-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="这一章到底在说什么？"><a href="#这一章到底在说什么？" class="headerlink" title="这一章到底在说什么？"></a>这一章到底在说什么？</h2><p>JavaScript中的类型有哪几种，及其它的一些用法。</p><h2 id="作者具体说了什么，怎么说的？"><a href="#作者具体说了什么，怎么说的？" class="headerlink" title="作者具体说了什么，怎么说的？"></a>作者具体说了什么，怎么说的？</h2><p><em>什么是类型：</em><br>对语言引擎和开发人员来说，类型是值的内部特征，它定义了值的行为，以使其区别于其他值。</p><h3 id="1-2-内置类型"><a href="#1-2-内置类型" class="headerlink" title="1.2 内置类型"></a>1.2 内置类型</h3><p><em>JavaScript有七种内置类型：</em></p><ol><li>空值(null)</li><li>未定义(undefined)</li><li>布尔值(boolean)</li><li>数字(number)</li><li>字符串(string)</li><li>对象(object)</li><li>符号(symbol, ES6中新增)</li></ol><pre><code>typeof null // objecttypeof undefined // undefinedtypeof true  // booleantypeof 42  // numbertypeof “42” // stringtypeof {life: 42} // object</code></pre><h3 id="1-3-值和类型"><a href="#1-3-值和类型" class="headerlink" title="1.3: 值和类型"></a>1.3: 值和类型</h3><p>JavaScript中的变量是没有类型，只有值才有。变量可以随时持有任何类型的值。<br>皇额角度来理解，js不做“类型强制”；也就是说，语言引擎不要求变量总是持有与其初始值同类型的值。一个变量可以现在被赋予字符串类型，随后又被赋值为数字类型值。</p><p><em>1.3.1: undefined和undeclared</em><br>已在作用域中声明但还没有赋值的变量，是undefined的，相反，还没有在作用域中声明过的变量，是undeclared 的。</p><pre><code>Var a;a // undefinedb // ReferencerError: b is not undefined</code></pre><p><em>1.3.2 typeof Undeclared</em></p><p>typeof有自己的安全防范机制。</p><pre><code>// 如果debug没有被声明// 这样会抛出错误if (debug) {    console.log(“debug is starting”)}// 这样是安全的if (typeof debug !== “undefined”) {    console.log(“debug is starting”)}</code></pre><h2 id="本章小结-小结"><a href="#本章小结-小结" class="headerlink" title="本章小结: 小结"></a>本章小结: 小结</h2><ol><li>JavaScript有七种内置类型：null, undefined, boolean, number, string, object和symbol，可以使用typeof运算符来查看具体类型</li><li>变量没有类型，但它们持有的值有类型。类型定义了值的行为特征。</li><li>很多开发人员将undefined和undeclared混为一谈，但在JavaScript中它们是两码事。undefined是值的一种，undeclared则表示变量还没有被声明过。</li><li>遗憾的是，JavaScript却将它们混为一谈，当我试图访问undeclared 变量时这样报错：ReferenceError: a is not defined,并且typeof对undefined和undeclared变量都返回”undefined”</li><li>然而，通过typeof的安全防范机制（组织报错）来检查undeclared变量，有时是个不错的办法。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一个经典的闭包面试题</title>
      <link href="/2020/03/12/%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E9%97%AD%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/03/12/%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E9%97%AD%E5%8C%85%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Shut up, show me the code!!!</p><pre><code>function showBiBao() {    for (var i = 0; i &lt; 5; i++) {      setTimeout( function timer() {          console.log(i);      }, 1000 );    }    console.log(i)}// 会输出什么showBiBao()</code></pre><p>会用到的两个知识点：</p><ul><li>闭包</li><li>setTimeout</li></ul><p>提示：<br>这个代码是有bug的，怎么解决？</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>第一步：先找出bug原因<br>1.1：for循环5次，那么应该设定了5个定时器，这个没错<br>1.2：setTimeout等待for循环执行完成后立即调用定时器<br>1.3：setTimeout被放在了队列的数据结构中（for循环），等待上下文的代码运行后再执行定时器，此时运行定时器，变量i已经变成了5（此时5个定时器的i都是5），所以输出全是5</p><p>第二步：怎么解决？<br>2.1：需要把每个定时器访问的变量独立起来，改变i的作用域<br>2.1：可以用闭包实现这个目的：在for循环里写一个闭包<br>2.3：show code</p><pre><code>function showListNumber() {    for(var i = 0; i &lt; 5; i++) {        (function(i) {            setTimeout(function timerr() {                console.log(i)            }, 1000)        })(i)    }    console.log(i)}showListNumber()</code></pre><p>第三步：还能怎么做？<br>3.1：改变i的作用域就可以消除bug<br>3.2：可以用let声明一个仅对当前{}（块作用域）内有效的变量。</p><pre><code>function useLetChange() {    for (let i = 0; i &lt; 5; i++) {      setTimeout( function timer() {          console.log(i);      }, 1000 );    }}useLetChange()</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>像程序员一样思考</title>
      <link href="/2020/03/12/%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/"/>
      <url>/2020/03/12/%E5%83%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>这个纳米学位项目的一个主要目的，就是让你练就像程序员一样的思维方式。长期从事编程工作的人时常会说起，编程的思维方式如何帮助他们处理生活中的其他问题。那么，“像程序员一样思考”究竟是什么意思呢？在这个纳米学位中，我们将重点关注程序员必须始终应用的5种特定思维方式。</p><ol><li>程序思维<br>程序思维是指创建出一套清晰明确的、计算机可以遵照执行的指令。<br>告诉一个人如何去排列扑克牌的顺序是非常简单的；但如果想让计算机去做这样的排序，你需要仔细想想怎么做。可一旦掌握了这种思维方式，你会发现计算机执行这个任务可比人快多了。</li><li>抽象思维<br>抽象思维是指找出相似点。用程序员的话来讲，就是找出看似不同事物间的一般性（generality）。<br>在学习这个纳米学位的过程中，您会访问数百个优达学城的网页，让程序员单独去编写每一个网页是不现实的。优达学城的程序员会借助“抽象”的力量来规避不必要的重复性工作。</li><li>系统思维<br>系统思维是指将大问题分解成多个小问题来解决。程序员在创建某个程序运行方式的计划时（通常是在纸上进行的），就会使用这种思维方式。这个计划分解为对问题的宏观思考和决策，以及程序中各模块协作解决问题的方法。如果这个解释不够明确，请不必担心！在纳米学位结束之前，您会对系统思维的含义有更清晰的了解。</li><li>技术同感思维<br>技术同感思维（Technological empathy）有多种形式。例如，计算机同感是指能够感同身受的理解计算机是什么、计算机如何运行、计算机擅长做什么、不擅长做什么。<br>计算机、软件程序以及编写这些程序时所使用的编程语言都是工具。如果不了解这些工具的基本工作方式，我们几乎无法编写出任何实质性的内容。</li><li>调试思维<br>调试思维是指一个系统化的过程，严格排查造成某个计算机程序无法正常运行的原因。<br>某个计算机程序无法正常运行，其原因是某部分代码存在错误（也被称为“Bug”）。在编程过程中出现这些错误是不可避免的，因此，每个优秀的程序员都有一套修改这些错误的系统化过程，通常如下：<br>收集证据（为什么程序无法正常运行）<br>形成观点（什么错误导致了这个问题）<br>测试观点（如果我的观点正确，怎样才能找到错误所在）<br>修正错误</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue中高德地图组件安装</title>
      <link href="/2020/03/12/Vue%E4%B8%AD%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2020/03/12/Vue%E4%B8%AD%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在最外边的index.html添加如下代码</p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;https://webapi.amap.com/maps?v=1.3&amp;key=9fefcf184cd8a194ee995943f23f6bf3&amp;plugin=AMap.DistrictSearch&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://webapi.amap.com/ui/1.0/main.js&quot;&gt;&lt;/script&gt;</code></pre></li><li><p>在 webpack.base.conf.js 加入 </p><pre><code></code></pre></li></ol><p>externals: {<br>    ‘AMap’: ‘AMap’<br>}</p><pre><code>3.在其他页面引用组件</code></pre><p>import GaoDeMap from ‘@/components/GaoDeMap’</p><pre><code></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetCode-08-字符串转换整数</title>
      <link href="/2020/03/12/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
      <url>/2020/03/12/leetcode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一：题目"><a href="#一：题目" class="headerlink" title="一：题目"></a>一：题目</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><p>说明：</p><p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p><p>示例 1:</p><pre><code>输入: &quot;42&quot;输出: 42</code></pre><p>示例 2:</p><pre><code>输入: &quot;   -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</code></pre><p>示例 3:</p><pre><code>输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</code></pre><p>示例 4:</p><pre><code>输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。     因此无法执行有效的转换。</code></pre><p>示例 5:</p><pre><code>输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。      因此返回 INT_MIN (−231) 。</code></pre><h2 id="二：思路解析"><a href="#二：思路解析" class="headerlink" title="二：思路解析"></a>二：思路解析</h2><ol><li>第一个思路需要把str中的空格去除，然后判断当前元素是否为数字或+/-，一个思路是使用正则表达式，找出目标元素，然后进行条件判断</li><li>另一个思路是使用parseInt将字符串解析为数字，然后进行条件判断。</li></ol><h2 id="三：解决代码JavaScript版本"><a href="#三：解决代码JavaScript版本" class="headerlink" title="三：解决代码JavaScript版本"></a>三：解决代码JavaScript版本</h2><p>我的方法：</p><pre><code>function myAtoi(str) {    var result = Math.max(Math.min(parseInt(str) || 0, 2147483647), -2147483648)    return result;}}</code></pre><h2 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h2><ol><li>parseInt使用起来是神器，但是需要仔细阅读文档，parseInt(str, num), num是2-36的数字，默认是10进制，使用的时候需要注意</li><li>使用正则表达式的方式不失为一个好方法，但是考虑到平常正则写的少，都是用到了临时学，真正的实际开发中可以使用，毕竟效率高些</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么编程语言的数组下标从0开始</title>
      <link href="/2020/03/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B/"/>
      <url>/2020/03/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>举个例子，一个小孩子将5个玩具从筐里拿出来，他是这么计数的：1，2，3，4，5 。而在编程领域，从数组里取值，是这么计数的：0，1，2，3，4。<br>是不是很神奇，那为何编程领域要这么做的？<br>通过查找资料和文章，发现原因如下：</p><h4 id="原因1-历史原因，别人是这么干的"><a href="#原因1-历史原因，别人是这么干的" class="headerlink" title="原因1:历史原因，别人是这么干的"></a>原因1:历史原因，别人是这么干的</h4><p>C语言设计者用0开始计数数组下标，之后的Java，JavsScript等高级语言都模仿了C语言，或者说，为了在一定成都上减少C语言程序员学习Java的学习成本，因此继续沿用了从0开始计数的习惯。</p><p>实际上，也有其他语言中数组并不是从0开始的，比如Matlab，甚至还有一些语言支持负数下标，比如Python。</p><h4 id="原因2-底层为了性能"><a href="#原因2-底层为了性能" class="headerlink" title="原因2:底层为了性能"></a>原因2:底层为了性能</h4><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移”。如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[n]就表示偏移n个type_size 的位置，所以计算a[n]的内存地址只需要下边这个公式：</p><pre><code>a[n]_address = base_address + n * type_size</code></pre><p>但是，如果数组从1开始计数，那么计算数组元素的a[n]的内存地址就会变成</p><pre><code>a[n]_address = base_address + (n-1)*type_size</code></pre><p>对比两个公式，如果从1开始编号，每次随机访问数组就多了一次减法运算，对于CPU来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的编程操作，效率的优化要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>三种方法实现阶乘</title>
      <link href="/2020/03/11/%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%98%B6%E4%B9%98/"/>
      <url>/2020/03/11/%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%98%B6%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h1 id="三种实现阶乘的方法"><a href="#三种实现阶乘的方法" class="headerlink" title="三种实现阶乘的方法"></a>三种实现阶乘的方法</h1><p>方法1</p><pre><code>function factorialize(num) {  // 如果num小于1，则终止  if (num&lt;0) {    return -1;  } else if (num === 0 || num === 1) {    // num=0或num=1，返回1，这个是定理    return 1;  } else{    return num * factorialize(num-1);  }}factorialize(5);</code></pre><p>第一个方法及其简单，else语句中是重复调用函数。但是这种方法好像有内存溢出的风险；</p><p>方法2：for循环</p><pre><code>function factorialize(num) {  if (num &lt; 0) {    return -1;  } else if (num===0 || num === 1) {    return 1;  } else {    for (var i = num -1; i &gt;= 1; i--) {      num *= i;    }  }  return num;}</code></pre><p>方法3：while循环</p><pre><code>function factorialize(num) {  var result = num;  if (num &lt; 1) {    return -1;  } else if (num===0 || num===1) {    return 1;  } else {    while (num &gt; 1) {      num--;      result *= num;    }  }  return result;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>罗马数字转整数</title>
      <link href="/2020/03/11/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>/2020/03/11/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>罗马数字包含以下七种字符:I，V，X，L，C，D和M。</p><p><em>字符</em>          <em>数值</em><br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。<br>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。</li><li>X可以放在L(50) 和C(100) 的左边，来表示 40 和90。</li><li>C可以放在D(500) 和M(1000) 的左边，来表示400 和900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1到 3999 的范围内。</li></ul><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><pre><code>let romanObj = {    &#39;I&#39;: 1,    &#39;V&#39;: 5,    &#39;X&#39;: 10,    &#39;L&#39;: 50,    &#39;C&#39;: 100,    &#39;D&#39;: 500,    &#39;M&#39;: 1000}let romanToInt = function(s) {    let max = 0;    let result = 0;    let sLength = s.length - 1;    for (var i = sLength; i &gt;= 0; i--) {        var currRoman = s[i];        var currVal = romanObj[currRoman];        result += currVal &gt; max ? currVal : -currVal;        max = Math.max(max, currVal);}    return result;}</code></pre><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h1><p>罗马字符串自右向左是数值递增的，而一旦出现不符合规律的，就应该减去该值，即将当前值取负。<br>该方法的关键就在于此，max中保存的就相当于最右边值，currVal是左边值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>利用Python进行两张图片比较</title>
      <link href="/2020/03/11/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E6%AF%94%E8%BE%83/"/>
      <url>/2020/03/11/%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h3 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h3><p>Python 2.7 or Python 3</p><h3 id="需要安装的包"><a href="#需要安装的包" class="headerlink" title="需要安装的包"></a>需要安装的包</h3><p>pytesseract<br>pytesser<br>Pillow</p><h3 id="达成目标"><a href="#达成目标" class="headerlink" title="达成目标"></a>达成目标</h3><p>比较两张图片是不是一个图片</p><h3 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h3><pre><code>python file.py</code></pre><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><pre><code>#!C:/Python27 &amp; Python3  #coding=utf-8 # 1. pip install pillow# 2. pip install pytesseract# 3. pip install pytesser# Run: python comporePicture.py import pytesseract  from pytesser import *  from PIL import Image,ImageEnhance,ImageFilter  import os  import fnmatch  import re,time  import urllib, random  #import hashlib    def getGray(image_file):     tmpls=[]     for h in range(0,  image_file.size[1]):#h        for w in range(0, image_file.size[0]):#w           tmpls.append( image_file.getpixel((w,h))  )     return tmpls  #获取平均灰度值   def getAvg(ls):    return sum(ls)/len(ls)  #比较100个字符有几个字符相同 def getMH(a,b):     dist = 0;     for i in range(0,len(a)):        if a[i]==b[i]:           dist=dist+1     return dist  def getImgHash(fne):     image_file = Image.open(fne) # 打开     image_file=image_file.resize((12, 12))#重置图片大小我12px X 12px     image_file=image_file.convert(&quot;L&quot;)#转256灰度图     Grayls=getGray(image_file)#灰度集合     avg=getAvg(Grayls)#灰度平均值     bitls=&#39;&#39;#接收获取0或1     #除去变宽1px遍历像素     for h in range(1,  image_file.size[1]-1):#h        for w in range(1, image_file.size[0]-1):#w           if image_file.getpixel((w,h))&gt;=avg:#像素的值比较平均值 大于记为1 小于记为0              bitls=bitls+&#39;1&#39;           else:              bitls=bitls+&#39;0&#39;     return bitls  &#39;&#39;&#39;&#39;&#39;             m2 = hashlib.md5()       m2.update(bitls)    print m2.hexdigest(),bitls    return m2.hexdigest() &#39;&#39;&#39;  #图片地址自行替换bijiaotupian = &quot;.//picture//kangshifu01.jpg&quot;openfile = &quot;.//picture&quot;a=getImgHash(bijiaotupian)  #被打开的文件夹中的图片files = os.listdir(openfile)#图片文件夹地址自行替换  for file in files:     b=getImgHash(&quot;.//picture//&quot;+str(file))     compare=getMH(a,b)     print(file,u&#39;相似度&#39;,str(compare)+&#39;%&#39;)#    if compare &gt;= 90:#        print(file,u&#39;相似度&#39;,str(compare)+&#39;%&#39;)#    else:#        pass</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>好玩的JS数组</title>
      <link href="/2020/03/11/%E5%A5%BD%E7%8E%A9%E7%9A%84JS%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/11/%E5%A5%BD%E7%8E%A9%E7%9A%84JS%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="好玩的js数组"><a href="#好玩的js数组" class="headerlink" title="好玩的js数组"></a>好玩的js数组</h1><p>数组去重</p><pre><code>function quChong(array) {    var reuslt = []    for (var i = 0; i &lt; array.length) {        var value = array[i]        if (!result.includes(value)) {            result.push(value)        }    }    return result}</code></pre><p>数组是否相等</p><pre><code>function arrayEqual(a, b) {    if (a.lenght != b.length) {        return false    } else {        for (var i = 0; i &lt; a.length; i++) {            var aValue = a[i]            var bValue = b[i]            if (aValue != bValue) {                return false            }        }        return true    }}</code></pre><p>两个数组的交集</p><pre><code>function jiaoJi(a, b) {    var result = []    for (var i = 0; i &lt; a.length; i++) {        var value = a[i]        if (b.includes(value)) {            result.push(value)        }    }    return result}</code></pre><p>寻找两个数组的不同</p><pre><code>function difference(a, b) {    var result = []    for (var i = 0; i &lt; a.length; i++) {        var value = a[i]        if (!b.includes(value)) {            result.push(value)        }    }    return result}</code></pre><p>在两个数组中的非共公元素</p><pre><code>function differenceTwo(a, b) {    var result = []    var aResult = difference(a, b)    var bResult = difference(b, a)    var result = aResult.concat(bResult)    return  result}</code></pre><p>判断两个数组是否包含</p><pre><code>function xiangDeng(a, b) {    for (var i = 0; i &lt; a.length; i++) {        var value = a[i]        if (!b.includes(value)) {            return false        }    }    return true}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-7-Z字形变换</title>
      <link href="/2020/03/11/leetcode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
      <url>/2020/03/11/leetcode-6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一：题目："><a href="#一：题目：" class="headerlink" title="一：题目："></a>一：题目：</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><pre><code>string convert(string s, int numRows);</code></pre><p>示例1：</p><pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot;</code></pre><p>示例2：</p><pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L     D     RE   O E   I IE C   I H   NT     S     G</code></pre><h2 id="二：思路解析"><a href="#二：思路解析" class="headerlink" title="二：思路解析"></a>二：思路解析</h2><ol><li>首先分析题目，输出内容其实就是重排之后的各行相加，那么问题就变为了按照规律排列，序号为n的字符在第几行</li><li>可以把字符串分为几组，然后每组按照规律push到不同行中，最后各行相加得出结果</li></ol><h2 id="三：解决代码JavaScript版本："><a href="#三：解决代码JavaScript版本：" class="headerlink" title="三：解决代码JavaScript版本："></a>三：解决代码JavaScript版本：</h2><p>我的方法：</p><pre><code>var convert = function(s, numRows) {    if (numRows === 0) {        return &#39;&#39;;    } else if (numRows === 1) {        return s;    }    var res = [];    var desc = false;    var index = 0;    var length = s.length    for (var i = 0; i &lt; length; i++) {        // console.log(&quot;res[index] is ===&gt;&gt;&gt;&quot;, res[index])        res[index] = res[index] ? res[index] + s[i] : s[i]        if (index % (numRows - 1) === 0) {            desc = !desc;        }        // console.log(&quot;index is ===&gt;&gt;&gt;&quot;, index)        index = desc ? index + 1: index - 1;        // console.log(&#39;for over res is ===&gt;&gt;&gt;&#39;, res)    }    return res.join(&#39;&#39;)}</code></pre><p>优秀答案：</p><pre><code>var betterConvert = function(s, numRows) {    var map = {}    var j = 0;    if (numRows &lt;= 1) {        return s;    }    var boo = true;    for (var i = 0; i &lt; s.length; i++) {        if (!map[j]) {            map[j] = &#39;&#39;;        }        map[j] = map[j] + s[i];        if (boo) {            j++;            if (j &gt;= numRows) {                j = j -2;                boo = false;            }        } else {            j--;            if (j &lt; 0) {                boo = true;                j = j + 2;            }        }    }    s = &#39;&#39;;    Object.keys(map).forEach(i =&gt; {        s = s + map[i];    })    return s;}</code></pre><h2 id="四：总结："><a href="#四：总结：" class="headerlink" title="四：总结："></a>四：总结：</h2><ol><li>优秀答案为使用了Map，执行效率确实比数组更好</li><li>代码运行时可以打印下运行过程，这样有助于理解</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/09/hello-world/"/>
      <url>/2020/03/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
